"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[226],{20226:function(e,t,r){r.r(t),r.d(t,{InferenceSession:function(){return l},Tensor:function(){return d},env:function(){return n},registerBackend:function(){return registerBackend}});let i={},o=[],registerBackend=(e,t,r)=>{if(t&&"function"==typeof t.init&&"function"==typeof t.createSessionHandler){let n=i[e];if(void 0===n)i[e]={backend:t,priority:r};else if(n.priority>r)return;else if(n.priority===r&&n.backend!==t)throw Error(`cannot register backend "${e}" using priority ${r}`);if(r>=0){let t=o.indexOf(e);-1!==t&&o.splice(t,1);for(let t=0;t<o.length;t++)if(i[o[t]].priority<=r){o.splice(t,0,e);return}o.push(e)}return}throw TypeError("not a valid backend")},resolveBackend=async e=>{let t=0===e.length?o:e,r=[];for(let e of t){let t=i[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;let i=!!t.initPromise;try{return i||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(o){i||r.push({name:e,err:o}),t.aborted=!0}finally{delete t.initPromise}}}throw Error(`no available backend found. ERR: ${r.map(e=>`[${e.name}] ${e.err}`).join(", ")}`)},n=new class{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}},a="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,s="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,f=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),h=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);a&&(f.set("int64",BigInt64Array),h.set(BigInt64Array,"int64")),s&&(f.set("uint64",BigUint64Array),h.set(BigUint64Array,"uint64"));let calculateSize=e=>{let t=1;for(let r=0;r<e.length;r++){let i=e[r];if("number"!=typeof i||!Number.isSafeInteger(i))throw TypeError(`dims[${r}] must be an integer, got: ${i}`);if(i<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${i}`);t*=i}return t};let Tensor=class Tensor{constructor(e,t,r){let i,o,n;if("string"==typeof e){if(i=e,n=r,"string"===e){if(!Array.isArray(t))throw TypeError("A string tensor's data must be a string array.");o=t}else{let r=f.get(e);if(void 0===r)throw TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))o=r.from(t);else if(t instanceof r)o=t;else throw TypeError(`A ${i} tensor's data must be type of ${r}`)}}else if(n=t,Array.isArray(e)){if(0===e.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)i="string",o=e;else if("boolean"===t)i="bool",o=Uint8Array.from(e);else throw TypeError(`Invalid element type of data array: ${t}.`)}else{let t=h.get(e.constructor);if(void 0===t)throw TypeError(`Unsupported type for tensor data: ${e.constructor}.`);i=t,o=e}if(void 0===n)n=[o.length];else if(!Array.isArray(n))throw TypeError("A tensor's dims must be a number array");let a=calculateSize(n);if(a!==o.length)throw Error(`Tensor's size(${a}) does not match data length(${o.length}).`);this.dims=n,this.type=i,this.data=o,this.size=a}static bufferToTensor(e,t){let r,i;if(void 0===e)throw Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw Error("Image height and width must be defined");let{height:o,width:n}=t,a=t.norm;r=void 0===a||void 0===a.mean?255:a.mean,i=void 0===a||void 0===a.bias?0:a.bias;let s=void 0!==t.bitmapFormat?t.bitmapFormat:"RGBA",f=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",h=o*n,d=new Float32Array("RGBA"===f?4*h:3*h),l=4,g=0,m=1,u=2,c=3,p=0,y=h,w=2*h,b=-1;"RGB"===s&&(l=3,g=0,m=1,u=2,c=-1),"RGBA"===f?b=3*h:"RBG"===f?(p=0,w=h,y=2*h):"BGR"===f&&(w=0,y=h,p=2*h);for(let t=0;t<h;t++,g+=l,u+=l,m+=l,c+=l)d[p++]=(e[g]+i)/r,d[y++]=(e[m]+i)/r,d[w++]=(e[u]+i)/r,-1!==b&&-1!==c&&(d[b++]=(e[c]+i)/r);let v="RGBA"===f?new Tensor("float32",d,[1,4,o,n]):new Tensor("float32",d,[1,3,o,n]);return v}static async fromImage(e,t){let r;let i="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,o="undefined"!=typeof ImageData&&e instanceof ImageData,n="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,a="undefined"!=typeof String&&(e instanceof String||"string"==typeof e),s={};if(i){let i=document.createElement("canvas"),o=i.getContext("2d");if(null!=o){let n=e.naturalHeight,a=e.naturalWidth;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");if(s.tensorFormat="RGBA",void 0!==t.height&&t.height!==n)throw Error("Image input config height doesn't match HTMLImageElement height");if(s.height=n,void 0!==t.width&&t.width!==a)throw Error("Image input config width doesn't match HTMLImageElement width");s.width=a}else s.tensorFormat="RGBA",s.height=n,s.width=a;i.width=a,i.height=n,o.drawImage(e,0,0,a,n),r=o.getImageData(0,0,a,n).data}else throw Error("Can not access image data")}else if(o){let i,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(i=t.resizedHeight,o=t.resizedWidth):(i=e.height,o=e.width),void 0!==t){if(s=t,void 0!==t.bitmapFormat&&"RGBA"!==t.bitmapFormat)throw Error("Image input config format must be RGBA for ImageData");s.bitmapFormat="RGBA"}else s.bitmapFormat="RGBA";if(s.height=i,s.width=o,void 0!==t){let t=document.createElement("canvas");t.width=o,t.height=i;let n=t.getContext("2d");if(null!=n)n.putImageData(e,0,0),r=n.getImageData(0,0,o,i).data;else throw Error("Can not access image data")}else r=e.data}else if(n){if(void 0===t)throw Error("Please provide image config with format for Imagebitmap");if(void 0!==t.bitmapFormat)throw Error("Image input config format must be defined for ImageBitmap");let i=document.createElement("canvas").getContext("2d");if(null!=i){let o=e.height,n=e.width;if(i.drawImage(e,0,0,n,o),r=i.getImageData(0,0,n,o).data,void 0!==t){if(void 0!==t.height&&t.height!==o)throw Error("Image input config height doesn't match ImageBitmap height");if(s.height=o,void 0!==t.width&&t.width!==n)throw Error("Image input config width doesn't match ImageBitmap width");s.width=n}else s.height=o,s.width=n;return Tensor.bufferToTensor(r,s)}throw Error("Can not access image data")}else if(a)return new Promise((r,i)=>{let o=document.createElement("canvas"),n=o.getContext("2d");if(!e||!n)return i();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{o.width=a.width,o.height=a.height,n.drawImage(a,0,0,o.width,o.height);let e=n.getImageData(0,0,o.width,o.height);if(void 0!==t){if(void 0!==t.height&&t.height!==o.height)throw Error("Image input config height doesn't match ImageBitmap height");if(s.height=o.height,void 0!==t.width&&t.width!==o.width)throw Error("Image input config width doesn't match ImageBitmap width");s.width=o.width}else s.height=o.height,s.width=o.width;r(Tensor.bufferToTensor(e.data,s))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return Tensor.bufferToTensor(r,s);throw Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var t,r;let i;let o=document.createElement("canvas").getContext("2d");if(null!=o){let n=this.dims[3],a=this.dims[2],s=this.dims[1],f=void 0!==e&&void 0!==e.format?e.format:"RGB",h=void 0!==e&&(null===(t=e.norm)||void 0===t?void 0:t.mean)!==void 0?e.norm.mean:255,d=void 0!==e&&(null===(r=e.norm)||void 0===r?void 0:r.bias)!==void 0?e.norm.bias:0,l=a*n;if(void 0!==e){if(void 0!==e.height&&e.height!==a)throw Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==n)throw Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===s&&"RGBA"!==e.format||3===s&&"RGB"!==e.format&&"BGR"!==e.format)throw Error("Tensor format doesn't match input tensor dims")}let g=0,m=1,u=2,c=3,p=0,y=l,w=2*l,b=-1;"RGBA"===f?(p=0,y=l,w=2*l,b=3*l):"RGB"===f?(p=0,y=l,w=2*l):"RBG"===f&&(p=0,w=l,y=2*l),i=o.createImageData(n,a);for(let e=0;e<a*n;g+=4,m+=4,u+=4,c+=4,e++)i.data[g]=(this.data[p++]-d)*h,i.data[m]=(this.data[y++]-d)*h,i.data[u]=(this.data[w++]-d)*h,i.data[c]=-1===b?255:(this.data[b++]-d)*h}else throw Error("Can not access image data");return i}reshape(e){return new Tensor(this.type,this.data,e)}};let d=Tensor;let InferenceSession=class InferenceSession{constructor(e){this.handler=e}async run(e,t,r){let i={},o={};if("object"!=typeof e||null===e||e instanceof d||Array.isArray(e))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let n=!0;if("object"==typeof t){if(null===t)throw TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof d)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw TypeError("'fetches' cannot be an empty array.");for(let e of(n=!1,t)){if("string"!=typeof e)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw RangeError(`'fetches' contains invalid output name: ${e}.`);i[e]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let e=!1,a=Object.getOwnPropertyNames(t);for(let r of this.outputNames)if(-1!==a.indexOf(r)){let o=t[r];(null===o||o instanceof d)&&(e=!0,n=!1,i[r]=o)}if(e){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(void 0===e[t])throw Error(`input '${t}' is missing in 'feeds'.`);if(n)for(let e of this.outputNames)i[e]=null;let a=await this.handler.run(e,i,o),s={};for(let e in a)Object.hasOwnProperty.call(a,e)&&(s[e]=new d(a[e].type,a[e].data,a[e].dims));return s}static async create(e,t,r,i){let o;let n={};if("string"==typeof e){if(o=e,"object"==typeof t&&null!==t)n=t;else if(void 0!==t)throw TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(o=e,"object"==typeof t&&null!==t)n=t;else if(void 0!==t)throw TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer){let a=0,s=e.byteLength;if("object"==typeof t&&null!==t)n=t;else if("number"==typeof t){if(!Number.isSafeInteger(a=t))throw RangeError("'byteOffset' must be an integer.");if(a<0||a>=e.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(s=e.byteLength-a,"number"==typeof r){if(!Number.isSafeInteger(s=r))throw RangeError("'byteLength' must be an integer.");if(s<=0||a+s>e.byteLength)throw RangeError(`'byteLength' is out of range (0, ${e.byteLength-a}].`);if("object"==typeof i&&null!==i)n=i;else if(void 0!==i)throw TypeError("'options' must be an object.")}else if(void 0!==r)throw TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw TypeError("'options' must be an object.");o=new Uint8Array(e,a,s)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let a=n.executionProviders||[],s=a.map(e=>"string"==typeof e?e:e.name),f=await resolveBackend(s),h=await f.createSessionHandler(o,n);return new InferenceSession(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};let l=InferenceSession}}]);